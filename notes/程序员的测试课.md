---
tags: [geek-time]
title: 程序员的测试课
created: '2023-12-10T12:26:51.909Z'
modified: '2023-12-10T13:01:32.813Z'
---

# 程序员的测试课

## 开篇词 | 为什么写测试是程序员的本职工作？

程序员的职责范围是随着时间逐步变化的

之所以程序员的职责范围一点点在拓展，关键原因就是，软件开发正在变得越来越复杂。

加入到程序员职责范围内的这些新东西，正是帮助程序员对抗越来越复杂的软件开发

程序员写测试就是为了编写高质量的代码

经过测试的代码，质量会更高。另一方面，要想写好测试，代码本身的质量也要高。

## 01 | 实战：实现一个 ToDo 的应用（上）

设计规范：对于输入参数的检测，由入口部分代码进行处理。

Repository 的问题以运行时异常的形式抛出，业务层不需要做任何处理。

## 02 | 实战：实现一个 ToDo 的应用（下）

我们测试的目标是我们的代码，而不是这个难以测试的程序库

由于其它程序库造成难以测试的问题，我们可以做一层层薄薄的封装，然后，在覆盖率检查中忽略它。封装和忽略，缺一不可。

## 03 | 程序员的测试与测试人员的测试有什么不同？

程序员的出发点是实现，而测试人员的出发点是业务。把这话翻译成你更熟悉的测试术语，那就是程序员的关注点是白盒测试，而测试人员则是黑盒测试。

从业务角度思考，确实是我们向测试人员学习的一个重要方向。但同样不要指望你换个角度思考一下就能把测试人员代替了。人的注意力是有限的，作为一个程序员，我们会把更多的时间放在关于技术实现的思考上，我们在发现问题上的训练强度是远远不够的。所以，人们常说，别用你的业余爱好去挑战别人吃饭的本事。

## 05 | 一个好的自动化测试长什么样？

测试代码也是代码，也要按照代码的标准去维护

我们用测试来保证代码的正确性，然而，测试的正确性如何保证呢？

## 06 | 测试不好做，为什么会和设计有关系？

软件设计是什么？软件设计就是在构建模型和规范。

可测试性是一个软件 / 模块对测试的支持程度，也就是当我执行了一个动作之后，我得花多大力气知道我做得到底对不对。

系统每个模块的可测试性不好，所以，最终只能把整个系统都集成起来进行系统测试。

不要在组件内部去创建对象

之所以说编写可组合的代码是可测试性的关键，是因为我们在测试的过程中要参与到组件的组装过程中，我们可能会用模拟对象代替真实对象。模拟对象对我们来说是完全可控的，而真实对象则不一定那么方便，比如真实对象可能会牵扯到外部资源，带来的问题可能比解决的问题更多。

接口是高层的抽象，属于我们业务的一部分。但要使用的第三方代码则属于一个具体的实现，它是细节，而不是业务的一部分。如果熟悉软件设计原则，你已经发现了，这其实就是依赖倒置原则。

使用 Spring Boot 的时候，我们写的 Controller 就是由框架回调的。使用 Flink 这样的大数据框架时，我们写的代码最终也是由框架回调的。

回调代码只做薄薄的一层，负责从框架代码转发到业务代码。

## 07 | Mock 框架：怎么让测试变得可控？

做测试，本质上就是在一个可控的环境下对被测系统 / 组件进行各种试探

怎么把不可控变成可控？第一步自然是隔离，第二步就是用一个可控的组件代替不可控的组件。换言之，用一个假的组件代替真的组件。

Stub、Dummy、Fake、Spy、Mock 等等。实话说，你今天问我这些名词的差异，我也需要去查找相关的资料，不能给出一个立即的答复。它们之间确实存在差异，但差异几乎到了可以忽略不计的份上。

verify 本身我都建议你不要用得太多。 verify 用起来会给人一种安全感，所以，会让人有一种多用的倾向，但这是一种错觉。我在讲测试框架时说过，verify 其实是一种断言。断言意味着这是一个函数应该具备的行为，是一种行为上的约定。 一旦设置了 verify，实际上也就约束了函数的实现。但 verify 约束的对象又是底层的组件，是一种实现细节。换言之，过度使用 verify 造成的结果就是把一个函数的实现细节约定死了。 过度使用 verify，在写代码的时候，你会有一种成就感。但是，一旦涉及代码修改，整个人就不好了。因为实现细节被 verify 锁定死，一旦修改代码，这些 verify 就很容易造成测试无法通过。 测试应该测试的是接口行为，而不是内部实现。所以，verify 虽好，还是建议少用。如果有一些场景不用 verify 就没有什么可断言的了，那该用 verify 还是要用。

## 08 | 单元测试应该怎么写？

任务分解的关键就是粒度要小

## 10 | 为什么 100% 的测试覆盖率是可以做到的？

其实程序员写测试不单单是写测试，同时，也是在发现自己代码中的不足，无论是设计上，还是代码本身。

## 11 | 集成测试：单元测试可以解决所有问题吗？

我们在编写每个单元时都会假设这些单元彼此之间能够很好地协同，但这个假设是不是一定成立呢？答案是不一定。

让一个个单元正常运行，我们靠的不是美好的预期，而是单元测试。同样，各个单元能够很好地协同，我们也不能靠预期，而是要靠集成测试。

## 12 | 实战：将 ToDo 应用扩展为一个 REST 服务

特意将业务核心部分隔离了出来，让它不依赖于任何具体的外部实现

Spring Data JPA 也允许我们自己手写 SQL，这是框架留给我们的优化手段。

目前国内的现状是很多团队会使用 MyBatis，他们给出的理由大多是自己写 SQL 比较好控制，尤其是对一些复杂场景来说更容易优化。不过，实际情况往往是，如果采用 JPA 的话，很多团队对于生成什么样的代码自己完全心里没有数，因为欠缺建模能力才用 MyBatis。而对于很多建模做得比较好的团队来说，使用 JPA 往往开发效率更高。

## 13 | 在 Spring 项目中如何进行单元测试？

很多人对于 Spring 的理解是从依赖注入容器开始的，但是，Spring 真正对行业的影响却是从它对原有开发模式的颠覆开始。

对于 J2EE 提出的问题，Spring 是承认的，但对其给出的解决方案，它却是不认的。因为应用服务器太重了，Spring 给社区带来了轻量级开发。

我们可以把 ApplicationContext 理解成 DI 容器，原本使用 DI 容器的优点就是可以不知晓依赖是怎么产生的，而在这段代码里，却知晓了 DI 容器，这就完全打破了 DI 容器设计的初衷

Spring 最大的优点是可以在代码层面上不依赖于 Spring，而错误的做法反而是深深地依赖于 Spring。

## 14 | 在 Spring 项目如何进行集成测试？

我们做测试的一个关键点就是不能随意修改代码，切记，不能为了测试的需要而修改代码。如果真的要修改，也许应该修改的是设计，而不仅仅是代码。

## 15 | 测试应该怎么配比？

因为各种历史原因，很多遗留项目是没有测试的。当项目发展了一段时间之后，团队开始关注产品质量，于是大家开始补测试。 在这种情况下，补测试是希望能够快速地建立起安全网，那必然是从系统测试入手来得快。只要写上一些高层测试，就能够覆盖到系统的大部分功能，属于“投资少见效快”的做法。

## 17 | TDD 就是先写测试后写代码吗？

极限编程之所以叫“极限”，它背后的理念就是把好的实践推向极限： 如果集成是好的，我们就尽早集成，推向极限就是每一次修改都集成，这就是持续集成。 如果程序员写测试是好的，我们就尽早测试，推向极限就是先写测试，再根据测试调整代码，这就是测试驱动开发。 如果代码评审是好的，我们就多做评审，推向极限就是随时随地代码评审，这就是结对编程。 如果客户交流是好的，我们就和客户多交流，推向极限就是客户与开发团队时时刻刻在一起，这就是现场客户。

我们在日常工作中也不妨多想想，有哪些做法是好的，如果把它推向极致会是什么样子。

## 18 | BDD 是什么东西？

软件变化的源动力在业务需求上

实例化需求（Specification by Example，SbE）

技术团队要更加贴近业务。

## 结束语 | 对代码的信心要从测试里来

人类的错误可以分为两大类型。第一类是“无知之错”，我们犯错是因为没有掌握相关知识。第二类是“无能之错”，我们犯错并非因为没有掌握相关知识，而是因为没有正确使用这些知识。无知之错，可以原谅，无能之错，不可原谅。

在外人看来，软件开发团队就应该有做好软件的能力，没做好肯定就是各种疏忽造成，这种错误是一种无能之错，要解决无能之错，显然就应该从改进工作方法和流程入手。于是，我们看到很多公司一旦觉得自己的公司需要提升软件质量了，首先是引入一套新的流程，无论是拼命写文档，还是引入专人负责。然而结果是软件团队疲于应付各种流程，软件的实际质量却并未得到有效改善。虽然初衷是好的，但因为诊断错了病因，用错了药方，治不好病也就在所难免了。

软件质量的病不在外部，而在内部。一个没有质量意识的团队只靠外部的推动很难做出高质量软件，这就像一个孩子如果仅仅靠家长的逼迫很难取得长期的好成绩一样。然而，软件质量靠流程却成了行业中的常态，不得不说，这是一个悲哀的结果。孩子想取得好成绩，归根结底是要有自己对学习的热爱，同样，软件质量要想得到真正的提升，要将做到内建质量（Build Quality In）。

内建质量就是要把软件开发中的每一个环节都加入质量的考虑：

业务负责人不能只要求上线日期，也要给出需求验证的业务目标和业务的验收标准； 产品经理不只是要给出产品说明，更要给出每个需求点的验收标准； 程序员不只给出代码，还要给出覆盖每行代码的自动化测试。

所谓内建质量，本质上就是用任务分解的方式，让每个环节都交付满足一定质量标准的交付物。其实，现在软件行业已经懂得了用迭代交付替代瀑布式交付，把大的需求拆分为小需求的集合，逐步交付给市场，尽早收集反馈，避免走过多的弯路。而内建质量则是通过在每个环节中加入对质量的思考，在每一个环节都要验证交付物是否符合目标，尽早发现问题。这样才不至于让测试人员成为最后的防洪堤坝，才不至于把大招憋成内伤，才有可能拿出一个高质量的软件。

在软件研发的环节加入质量的思考，对很多人来说，是一件有难度的事。因为在他们看来，这么做是增加了工作量。比如很多程序员会说“写测试就是浪费时间”。然而，真的是这样吗？

一个内建质量的团队，可以在工作的诸多环节规避掉很多问题。从软件生命周期的角度看，规避了这些问题可以从整体上节省时间。虽然很多人学过软件工程的基本理论，但这种东西实在太反直觉，就像不相信 0.99… = 1，也有很多人不相信前期的投入会给团队带来长期的回报。 但这种不相信其实更多是一种不愿意相信，因为相信了就意味着要做出改变，而改变才是很多人真正惧怕的。是的，很多人真正的不愿意是“改变”这件事。正是因为有太多的人不愿意改变，才使得愿意改变的人很容易脱颖而出。

一旦你想明白了这一点，你就能理解软件研发中暴露的很多错误根本不是无能之错，而是无知之错。换言之，正是因为很多人只愿意墨守成规，所以，他们根本看不到自己其实是欠缺了一个质量的维度，而这个维度上也有着一张知识网。

业务逻辑复杂和代码复杂是两回事

优秀的代码平平无奇，糟糕的代码千奇百怪。
